# Importando bibliotecas
from rich.console import Console # Adicionando a fun√ß√£o de console da biblioteca
console = Console()

# Fun√ß√£o de convers√£o
def binary_to_decimal(binary_num:str): # Converte n√∫meros bin√°rios em decimais
    decimal_num = int(binary_num, 2)
    return decimal_num

# Fun√ß√µes de c√°lculo
def binary_addition(bin1, bin2, length): # Adi√ß√£o
    # Declara as v√°riaveis relacionadas a quantia de bits
    length = int(float(length))
    original_length = length

    # Verifica se a quantidade de bits √© menor ou igual a 0
    if length <= 0:
        raise ValueError("[ A quantidade de bits n√£o pode ser menor que 1 bit! ]")

    # Verifica se todos os n√∫meros s√£o compostos de apenas zeros 
    if all(bit == '0' for bit in bin1) and all(bit == '0' for bit in bin2):
        return '0' * length

    # Verifica se o primeiro n√∫mero √© composto de apenas zeros
    if all(bit == '0' for bit in bin1):
        return bin2.zfill(length)

    # Verifica se o segundo n√∫mero √© composto de apenas zeros
    if all(bit == '0' for bit in bin2):
        return bin1.zfill(length)

    # Remove zeros √† esquerda
    bin1 = bin1.lstrip('0')
    bin2 = bin2.lstrip('0')

    # Preenche os n√∫meros bin√°rios com zeros a esquerda com base na quantia de bits definida
    length = max(len(bin1), len(bin2))
    bin1 = bin1.zfill(length)
    bin2 = bin2.zfill(length)

    # Declarando v√°riaveis de c√°lculo
    result = ''
    carry = 0

    # Itera os bin√°rios da direita para a esquerda
    for i in range(length - 1, -1, -1):
        bit1 = int(bin1[i])
        bit2 = int(bin2[i])

        # Calcule a soma dos bits atuais junto com o "empr√©stimo"
        current_sum = bit1 + bit2 + carry

        # Anexa o resultado ao in√≠cio do resultado anterior
        result = str(current_sum % 2) + result

        # Atualiza o "empr√©stimo" para a pr√≥xima itera√ß√£o
        carry = current_sum // 2

    # Se sobrar um "empr√©stimo" ap√≥s a itera√ß√£o, anexe-o ao resultado
    if carry:
        result = '1' + result

    length = original_length # Re difinindo a quantia de bits

    # Verifique se o resultado excede a quantia de bits
    if len(result) > length:
        raise ValueError(f'[ O resultado excede {original_length} bits! ]')

    # Retorna o resultado e preenche com zeros √† esquerda com base na quantia de bits definida
    return result.zfill(length)

def binary_subtraction(bin1, bin2, length): # Subtra√ß√£o
    # Declara as v√°riaveis relacionadas a quantia de bits
    length = int(float(length))
    original_length = length

    # Verifica se a quantidade de bits √© menor ou igual a 0
    if length <= 0:
        raise ValueError("[ The length cannot be less than 1 bit! ]")

    # Verifica se todos os n√∫meros s√£o compostos de apenas zeros 
    if all(bit == '0' for bit in bin1) and all(bit == '0' for bit in bin2):
        return '0' * length

    # Converte n√∫meros bin√°rios em inteiros para compara√ß√£o
    int_bin1 = int(bin1, 2)
    int_bin2 = int(bin2, 2)
    
    # Verifica se o segundo n√∫mero bin√°rio √© maior que o primeiro
    if int_bin2 > int_bin1:
        raise ValueError('[ Resultado negativo! ]')

    # Verifica se o segundo n√∫mero √© composto de apenas zeros
    if all(bit == '0' for bit in bin2):
        return bin1.zfill(length)
    
    # Preenche os n√∫meros bin√°rios com zeros a esquerda com base na quantia de bits definida
    length = max(len(bin1), len(bin2))
    bin1 = bin1.zfill(length)
    bin2 = bin2.zfill(length)
    
    # Declarando v√°riaveis de c√°lculo
    result = ''
    borrow = 0
    
    # Itera os bin√°rios da direita para a esquerda
    for i in range(length - 1, -1, -1):
        bit1 = int(bin1[i])
        bit2 = int(bin2[i])
        
        # Subtrai os bits atuais junto com o "empr√©stimo"
        current_diff = bit1 - bit2 - borrow
        
        # Se a diferen√ßa for negativa, pegue "emprestado" do pr√≥ximo bit de ordem superior
        if current_diff < 0:
            current_diff += 2
            borrow = 1
        else:
            borrow = 0
        
        # Anexa o resultado ao in√≠cio do resultado anterior
        result = str(current_diff) + result
    
    length = original_length # Re difinindo a quantia de bits

    # Retorna o resultado e preenche com zeros √† esquerda com base na quantia de bits definida
    return result.zfill(length)

def binary_multiplication(bin1, bin2, length): # Multiplica√ß√£o
    # Declara as v√°riaveis relacionadas a quantia de bits
    length = int(float(length))
    original_length = length

    # Verifica se a quantidade de bits √© menor ou igual a 0
    if length <= 0:
        raise ValueError("[ A quantidade de bits n√£o pode ser menor que 1 bit! ]")

    # Fun√ß√£o b√°sica de adi√ß√£o bin√°ria
    def binary_add(a, b):
        result = []
        carry = 0
        for i in range(max(len(a), len(b))):
            bit_a = int(a[-1 - i]) if i < len(a) else 0
            bit_b = int(b[-1 - i]) if i < len(b) else 0
            total = bit_a + bit_b + carry
            result.append(str(total % 2))
            carry = total // 2
        if carry:
            result.append(str(carry))
        return ''.join(result[::-1])

    # Verifica se todos os n√∫meros s√£o compostos de apenas zeros 
    if all(bit == '0' for bit in bin1) and all(bit == '0' for bit in bin2):
        return '0' * length

    # Remove zeros √† esquerda
    bin1 = bin1.lstrip('0')
    bin2 = bin2.lstrip('0')

    # Se depois de remover os zeros √† esquerda, alguma das entradas estiver vazia, retorne "0"
    if not bin1 or not bin2:
        return '0' * length

    # Multiplique cada bit de bin1 por bin2 inteiro e mude o resultado
    result = "0"
    for i in range(len(bin1)):
        if bin1[-1 - i] == "1":
            temp = bin2 + "0" * i
            result = binary_add(result, temp)

    length = original_length # Re difinindo a quantia de bits

    # Verifique se o resultado excede a quantia de bits
    if len(result) > length:
        raise ValueError(f'[ O resultado excede {original_length} bits! ]')
    
    # Retorna o resultado e preenche com zeros √† esquerda com base na quantia de bits definida
    return result.zfill(length)

# Fun√ß√£o de c√°lculo com base na escolha do usu√°rio
def binary_calculation_BA(first_b_num:str, second_b_num:str, choice, length):
    match choice:
        case 1: # Adi√ß√£o
            try:
                console.print(f'\n[bold][orange1][cyan]| üòé [ Resultado Decimal ]: [purple]{binary_to_decimal(first_b_num)}[/][/] + [purple]{binary_to_decimal(second_b_num)}[/] = [purple]{binary_to_decimal(binary_addition(first_b_num, second_b_num, length))}[/][/]')
                console.print(f'\n[bold][orange1][cyan]| üòé [ Resultado Bin√°rio ]: [green]{first_b_num}[/][/] + [green]{second_b_num}[/] = [green]{binary_addition(first_b_num, second_b_num, length)}[/][/]\n')
            except ValueError as e:
                console.print(f'\n[bold][red]| üòï ERRO -> [orange1][underline]{e}[/][/][/]\n')
        case 2: # Subtra√ß√£o
            try:
                console.print(f'\n[bold][orange1][cyan]| üòé [ Resultado Decimal ]: [purple]{binary_to_decimal(first_b_num)}[/][/] - [purple]{binary_to_decimal(second_b_num)}[/] = [purple]{binary_to_decimal(binary_subtraction(first_b_num, second_b_num, length))}[/][/]')
                console.print(f'\n[bold][orange1][cyan]| üòé [ Resultado Bin√°rio ]: [green]{first_b_num}[/][/] - [green]{second_b_num}[/] = [green]{binary_subtraction(first_b_num, second_b_num, length)}[/][/]\n')
            except ValueError as e:
                console.print(f'\n[bold][red]| üòï ERRO -> [orange1][underline]{e}[/][/][/]\n')
        case 3: # Multiplica√ß√£o
            try:
                console.print(f'\n[bold][orange1][cyan]| üòé [ Resultado Decimal ]: [purple]{binary_to_decimal(first_b_num)}[/][/] * [purple]{binary_to_decimal(second_b_num)}[/] = [purple]{binary_to_decimal(binary_multiplication(first_b_num, second_b_num, length))}[/][/]')
                console.print(f'\n[bold][orange1][cyan]| üòé [ Resultado Bin√°rio ]: [green]{first_b_num}[/][/] * [green]{second_b_num}[/] = [green]{binary_multiplication(first_b_num, second_b_num, length)}[/][/]\n')
            except ValueError as e:
                console.print(f'\n[bold][red]| üòï ERRO -> [orange1][underline]{e}[/][/][/]\n')
